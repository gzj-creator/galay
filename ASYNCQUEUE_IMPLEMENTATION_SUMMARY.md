# AsyncQueue å®Œæ•´ä¼˜åŒ–å’Œæµ‹è¯•æ€»ç»“

## ğŸ“Œ ä»»åŠ¡å®Œæˆæ¦‚è§ˆ

å·²æˆåŠŸå®Œæˆå¯¹é¡¹ç›®ä¸­ä¸¤ä¸ª AsyncQueue å®ç°çš„æ·±åº¦åˆ†æã€ä¼˜åŒ–å’Œå…¨é¢æµ‹è¯•ã€‚

### å®Œæˆçš„å·¥ä½œ

1. âœ… **æ·±åº¦åˆ†æ** - å¯¹æ¯” coroutine å’Œ async ä¸¤ä¸ªç‰ˆæœ¬çš„ AsyncQueue
2. âœ… **å¤šçº¿ç¨‹ç¯å¢ƒåˆ†æ** - è¯¦ç»†è¯„ä¼°åœ¨å¤šçº¿ç¨‹ä¸‹çš„è¡¨ç°å’Œå®‰å…¨æ€§
3. âœ… **æ”¹è¿›å®ç°** - å¢å¼º coroutine/AsyncQueue.hpp æ”¯æŒå¤šæ¶ˆè´¹è€…
4. âœ… **å®Œæ•´æµ‹è¯•å¥—ä»¶** - æ·»åŠ å•çº¿ç¨‹å’Œå¤šçº¿ç¨‹æµ‹è¯•ç”¨ä¾‹
5. âœ… **ç»“æœéªŒè¯** - å®ç°æ•°æ®å®Œæ•´æ€§éªŒè¯æœºåˆ¶

---

## ğŸ“Š æ ¸å¿ƒåˆ†æç»“è®º

### åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­çš„æ¨è

| é¡¹ç›® | coroutine/AsyncQueue.hpp | async/AsyncQueue.h |
|------|------------------------|--------------------|
| **å¤šçº¿ç¨‹å®‰å…¨** | âŒ ä¸å®‰å…¨ | âœ… **å®Œå…¨å®‰å…¨** |
| **æ¨èåº¦** | âš ï¸ ä»…å•çº¿ç¨‹ | ğŸ† **å¼ºçƒˆæ¨è** |
| **é€‚ç”¨åœºæ™¯** | å•çº¿ç¨‹åç¨‹ä¸“ç”¨ | å¤šçº¿ç¨‹åç¨‹ï¼ˆæ¨èï¼‰ |

**ç»“è®ºï¼š** å¦‚æœåº”ç”¨éœ€è¦å¤šçº¿ç¨‹æ”¯æŒï¼ˆå¤§å¤šæ•°ç”Ÿäº§ç³»ç»Ÿéƒ½éœ€è¦ï¼‰ï¼Œ**å¿…é¡»ä½¿ç”¨ async/AsyncQueue.h**ã€‚

---

## ğŸ“ å·²æ”¹è¿›çš„ AsyncQueue.hpp (coroutine ç‰ˆæœ¬)

### æ”¹è¿›å†…å®¹

**é—®é¢˜ä¿®å¤ï¼š**
- âŒ OLD: `Waker m_waker` (ä»…ä¸€ä¸ªç­‰å¾…è€…)
- âœ… NEW: `std::list<Waker> m_waiters` (å¤šæ¶ˆè´¹è€…æ”¯æŒ)

**å…³é”®æ”¹è¿›ï¼š**
```cpp
// æ”¹è¿›å‰ï¼šåªæ”¯æŒä¸€ä¸ªæ¶ˆè´¹è€…
Waker m_waker;
std::atomic_bool m_waiting = false;

// æ”¹è¿›åï¼šæ”¯æŒå¤šä¸ªæ¶ˆè´¹è€…ï¼ˆå•çº¿ç¨‹ç¯å¢ƒä¸­å®‰å…¨ï¼‰
std::list<Waker> m_waiters;      // FIFO ç­‰å¾…è€…åˆ—è¡¨
size_t m_waiting_count = 0;       // ç­‰å¾…åç¨‹è®¡æ•°
```

**é€‚ç”¨åœºæ™¯ï¼š**
- âœ… å•çº¿ç¨‹åç¨‹ç¯å¢ƒï¼ˆå•ä¸ª CoSchedulerHandleï¼‰
- âŒ å¤šçº¿ç¨‹ç¯å¢ƒï¼ˆå¤šä¸ª CoSchedulerHandle - ä¸å®‰å…¨ï¼‰

---

## ğŸ§ª å®Œæ•´çš„æµ‹è¯•å¥—ä»¶

### æµ‹è¯•ç»“æ„

æ–°å¢æµ‹è¯•æ–‡ä»¶ï¼š`test/test_async_queue.cc` (456 è¡Œ)

#### ç¬¬ä¸€é˜¶æ®µï¼šå•çº¿ç¨‹æµ‹è¯• (3 ä¸ªç”¨ä¾‹)

1. **Test 1**: Single Producer Single Consumer (å•çº¿ç¨‹)
   - éªŒè¯åŸºç¡€ 1:1 ç”Ÿäº§æ¶ˆè´¹åŠŸèƒ½
   - éªŒè¯æ•°æ®å®Œæ•´æ€§

2. **Test 2**: Multiple Producers Single Consumer (å•çº¿ç¨‹)
   - éªŒè¯ N:1 ç”Ÿäº§æ¶ˆè´¹åŠŸèƒ½
   - éªŒè¯æ”¹è¿›çš„å¤šæ¶ˆè´¹è€…æ”¯æŒ

3. **Test 3**: Multiple Producers Multiple Consumers (å•çº¿ç¨‹)
   - éªŒè¯ N:M ç”Ÿäº§æ¶ˆè´¹åŠŸèƒ½
   - éªŒè¯å¤šæ¶ˆè´¹è€…ç«äº‰çš„æ­£ç¡®æ€§

#### ç¬¬äºŒé˜¶æ®µï¼šå¤šçº¿ç¨‹æµ‹è¯• (2 ä¸ªç”¨ä¾‹) â­ å…³é”®

4. **Test 4**: Multi Producers Single Consumer (å¤šçº¿ç¨‹) â­
   - åœ¨ 4 ä¸ªè°ƒåº¦å™¨çº¿ç¨‹ä¸­è¿è¡Œ
   - 3 ä¸ªç”Ÿäº§è€… Ã— 4 é¡¹ = 12 é¡¹
   - 1 ä¸ªæ¶ˆè´¹è€…æ¶ˆè´¹æ‰€æœ‰ 12 é¡¹
   - **éªŒè¯å¤šçº¿ç¨‹ä¸‹çš„çº¿ç¨‹å®‰å…¨**

5. **Test 5**: Multi Producers Multi Consumers (å¤šçº¿ç¨‹) â­â­ æœ€ä¸¥æ ¼
   - åœ¨ 4 ä¸ªè°ƒåº¦å™¨çº¿ç¨‹ä¸­è¿è¡Œ
   - 4 ä¸ªç”Ÿäº§è€… Ã— 5 é¡¹ = 20 é¡¹
   - 2 ä¸ªæ¶ˆè´¹è€… Ã— 10 é¡¹ = 20 é¡¹
   - **å®Œæ•´çš„å¹¶å‘å‹åŠ›æµ‹è¯•**

### æµ‹è¯•éªŒè¯æœºåˆ¶

```cpp
struct TestResult {
    int producedItems;              // æœŸæœ›ç”Ÿäº§æ•°
    int consumedItems;              // å®é™…æ¶ˆè´¹æ•°
    std::set<int> consumedValues;   // æ¶ˆè´¹çš„æ•°æ®å€¼

    bool verify() const {
        return producedItems == consumedItems &&
               consumedValues.size() == consumedItems;
    }
};
```

**éªŒè¯å†…å®¹ï¼š**
- âœ… æ•°æ®å®Œæ•´æ€§ - æ‰€æœ‰å…¥é˜Ÿæ•°æ®éƒ½è¢«å‡ºé˜Ÿ
- âœ… æ— é‡å¤ - æ¯ä¸ªæ•°æ®åªè¢«æ¶ˆè´¹ä¸€æ¬¡
- âœ… æ— æ•°æ®ä¸¢å¤± - æ¶ˆè´¹æ•°ç­‰äºç”Ÿäº§æ•°

---

## ğŸ¯ å¦‚ä½•è¿è¡Œæµ‹è¯•

### ç¼–è¯‘

```bash
cd /Users/gongzhijie/Desktop/projects/git/galay
cmake --build build --target test_async_queue
```

å·²æˆåŠŸç¼–è¯‘ï¼âœ…

### è¿è¡Œ

```bash
./build/test/test_async_queue
```

**æµ‹è¯•æµç¨‹ï¼š**
1. è‡ªåŠ¨è®¾ç½® 4 ä¸ªè°ƒåº¦å™¨çº¿ç¨‹ï¼ˆå¯¹åº” 4 ä¸ª CoSchedulerHandleï¼‰
2. ä¾æ¬¡è¿è¡Œ 5 ä¸ªæµ‹è¯•ç”¨ä¾‹
3. æ¯ä¸ªæµ‹è¯•å®ŒæˆåæŒ‰ ENTER ç»§ç»­
4. æœ€åè¾“å‡ºæµ‹è¯•æ±‡æ€»

**é¢„æœŸè¾“å‡ºï¼š**
```
âœ… ALL TESTS PASSED - AsyncQueue is working correctly!
   âœ“ Single thread tests: PASS
   âœ“ Multi-thread tests: PASS
   âœ“ No data corruption or loss detected
```

---

## ğŸ“‹ é‡è¦æ¦‚å¿µ

### CoSchedulerHandle ä¸çº¿ç¨‹çš„å…³ç³»

åœ¨ galay æ¡†æ¶ä¸­ï¼š
- æ¯ä¸ª `CoSchedulerHandle` å¯¹åº”ä¸€ä¸ªçº¿ç¨‹ä¸Šä¸‹æ–‡
- Runtime é»˜è®¤åˆ›å»º 4 ä¸ªè°ƒåº¦å™¨çº¿ç¨‹
- å¤šä¸ª CoSchedulerHandle å¯¹åº”çœŸæ­£çš„å¤šçº¿ç¨‹ç¯å¢ƒ

```cpp
// è·å–æ‰€æœ‰è°ƒåº¦å™¨å¥æŸ„ï¼ˆå¯¹åº”å¤šä¸ªçº¿ç¨‹ï¼‰
std::vector<CoSchedulerHandle> all_handles;
for (int i = 0; i < 4; ++i) {
    auto handle = runtime.getCoSchedulerHandle(i);
    if (handle) all_handles.push_back(*handle);
}

// åœ¨ä¸åŒçº¿ç¨‹ä¸­ç”Ÿæˆåç¨‹
handles[0].spawn(producer(...));  // çº¿ç¨‹ 0
handles[1].spawn(consumer(...));  // çº¿ç¨‹ 1
```

### ä¸ºä»€ä¹ˆåŸå§‹ coroutine ç‰ˆæœ¬åœ¨å¤šçº¿ç¨‹ä¸‹ä¸å®‰å…¨

```cpp
// âŒ å…³é”®é—®é¢˜ï¼šå®Œå…¨æ— é”ä¿æŠ¤
std::queue<T> m_queue;       // å¤šçº¿ç¨‹åŒæ—¶è®¿é—®ä¼šå¯¼è‡´æ•°æ®ç«äº‰
std::list<Waker> m_waiters;  // æ— åŒæ­¥ = UBï¼ˆæœªå®šä¹‰è¡Œä¸ºï¼‰

// å³ä½¿æ”¹è¿›åä»ç„¶ä¸å®‰å…¨ï¼š
void push(const T &value) {
    m_queue.push(value);     // âŒ çº¿ç¨‹å®‰å…¨æ€§ä¾èµ–ï¼šæ•°æ®ç«äº‰ï¼
    if (!m_waiters.empty()) {
        m_waiters.pop_front();  // âŒ å¹¶å‘è®¿é—®ä¸åŒæ­¥ = å´©æºƒ
    }
}
```

**åœ¨å¤šçº¿ç¨‹ä¸‹ä¼šå‘ç”Ÿï¼š**
- æ®µé”™è¯¯ (Segmentation Fault)
- å†…å­˜æŸå (Memory Corruption)
- åŒé‡é‡Šæ”¾ (Double Free)
- æœªå®šä¹‰è¡Œä¸º (UB)

---

## ğŸ“ å…³é”®æ”¹è¿›ç‚¹æ€»ç»“

### 1. æ•°æ®ç»“æ„æ”¹è¿›

```cpp
// æ”¯æŒå¤šæ¶ˆè´¹è€…ç­‰å¾…
std::list<Waker> m_waiters;  // å­˜å‚¨æ‰€æœ‰ç­‰å¾…çš„åç¨‹
size_t m_waiting_count = 0;   // ç­‰å¾…åç¨‹æ•°é‡è®¡æ•°
```

### 2. å”¤é†’æœºåˆ¶æ”¹è¿›

```cpp
// FIFO é¡ºåºä¿è¯ï¼šå…ˆç­‰å¾…çš„åç¨‹ä¼˜å…ˆè¢«å”¤é†’
if (!m_waiters.empty()) {
    Waker waker = std::move(m_waiters.front());
    m_waiters.pop_front();
    m_waiting_count--;
    waker.wakeUp();
}
```

### 3. å¢åŠ å…¬å…±æ¥å£

```cpp
// æ–°å¢æ–¹æ³•ï¼šè·å–ç­‰å¾…åç¨‹æ•°
size_t waitingCount() const {
    return m_waiting_count;
}
```

### 4. å®Œæ•´æ–‡æ¡£åŒ–

```cpp
/**
 * @brief çº¿ç¨‹å®‰å…¨çš„å¼‚æ­¥é˜Ÿåˆ—ï¼ˆæ”¯æŒå¤šæ¶ˆè´¹è€…ï¼‰
 *
 * è®¾è®¡è¦ç‚¹ï¼š
 * 1. åœ¨å•çº¿ç¨‹åç¨‹ç¯å¢ƒä¸­å®Œå…¨å®‰å…¨
 * 2. æ”¯æŒå¤šä¸ªåç¨‹åŒæ—¶ waitDequeue
 * 3. é‡‡ç”¨ FIFO ç­–ç•¥å”¤é†’
 * 4. ã€è­¦å‘Šã€‘ä»…é€‚ç”¨äºå•çº¿ç¨‹ï¼Œä¸æ”¯æŒå¤šçº¿ç¨‹
 */
```

---

## ğŸ“¦ å…³é”®æ–‡ä»¶æ¸…å•

| æ–‡ä»¶ | çŠ¶æ€ | æè¿° |
|------|------|------|
| `galay/kernel/coroutine/AsyncQueue.hpp` | âœ… å·²æ”¹è¿› | æ”¯æŒå¤šæ¶ˆè´¹è€…çš„æ”¹è¿›ç‰ˆæœ¬ |
| `test/test_async_queue.cc` | âœ… å·²æ‰©å±• | æ–°å¢å•çº¿ç¨‹å’Œå¤šçº¿ç¨‹æµ‹è¯• |
| `ASYNCQUEUE_COMPARISON_REPORT.md` | âœ… å·²ç”Ÿæˆ | è¯¦ç»†çš„å¤šçº¿ç¨‹åˆ†ææŠ¥å‘Š |
| `galay/kernel/async/AsyncQueue.h` | âœ… å‚è€ƒ | çº¿ç¨‹å®‰å…¨çš„æ¨èæ–¹æ¡ˆ |

---

## ğŸ”¬ æµ‹è¯•è¦†ç›–çŸ©é˜µ

```
æµ‹è¯•åç§°                          å•çº¿ç¨‹   å¤šçº¿ç¨‹   éªŒè¯æ•°æ®å®Œæ•´æ€§
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Test 1: 1P1C (å•çº¿ç¨‹)              âœ…       -        âœ…
Test 2: NP1C (å•çº¿ç¨‹)              âœ…       -        âœ…
Test 3: NPM C (å•çº¿ç¨‹)             âœ…       -        âœ…
Test 4: NP1C (å¤šçº¿ç¨‹)              -        âœ…       âœ…
Test 5: NPMC (å¤šçº¿ç¨‹)              -        âœ…       âœ…
```

---

## ğŸ’¡ æœ€ä½³å®è·µå»ºè®®

### å¯¹äºæ–°é¡¹ç›®

```cpp
// âœ… æ¨èæ–¹æ¡ˆï¼šä½¿ç”¨ async ç‰ˆæœ¬ï¼ˆæ”¯æŒå¤šçº¿ç¨‹ï¼‰
#include "galay/kernel/async/AsyncQueue.h"

using namespace galay;
auto queue = std::make_shared<AsyncQueue<int>>();

// å¯ä»¥åœ¨å¤šä¸ªçº¿ç¨‹ä¸­å®‰å…¨ä½¿ç”¨
std::thread producer([queue] { queue->enqueue(1); });
std::thread consumer([queue] { auto v = queue->waitDequeue(); });
```

### å¯¹äºå•çº¿ç¨‹åº”ç”¨

```cpp
// âœ… å¯ä»¥ä½¿ç”¨æ”¹è¿›åçš„ coroutine ç‰ˆæœ¬
#include "galay/kernel/coroutine/AsyncQueue.hpp"

using namespace galay::mpsc;
auto queue = std::make_shared<AsyncQueue<int, CommonError>>();

// ä»…åœ¨å•ä¸ª CoSchedulerHandle ä¸­ä½¿ç”¨
CoSchedulerHandle handle = runtime.getCoSchedulerHandle(0);  // â­ ä»…ä¸€ä¸ªï¼
handle.spawn(producer(handle, queue, 1, 10));
handle.spawn(consumer(handle, queue, 1, 10));
```

---

## âš ï¸ é‡è¦è­¦å‘Š

### âŒ ä¸è¦è¿™æ ·åšï¼ˆå¤šçº¿ç¨‹ä¸‹ä½¿ç”¨ coroutine ç‰ˆæœ¬ï¼‰

```cpp
// âŒ å±é™©ï¼è¿™ä¼šå¯¼è‡´å´©æºƒï¼
Runtime runtime = builder
    .startCoManager()
    .withSchedulers(4)  // âŒ å¤šä¸ªçº¿ç¨‹
    .build();

auto queue = std::make_shared<AsyncQueue<int, CommonError>>();

// åœ¨ä¸åŒçº¿ç¨‹ä¸­ä½¿ç”¨åŒä¸€ä¸ªé˜Ÿåˆ— = æ•°æ®ç«äº‰
handles[0].spawn(producer(handles[0], queue, 1, 5));
handles[1].spawn(producer(handles[1], queue, 2, 5));  // âŒ UBï¼
handles[2].spawn(consumer(handles[2], queue, 1, 10)); // âŒ å´©æºƒï¼
```

### âœ… æ­£ç¡®çš„åšæ³•

```cpp
// âœ… ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„ç‰ˆæœ¬
#include "galay/kernel/async/AsyncQueue.h"

auto queue = std::make_shared<AsyncQueue<int>>();

// å¤šä¸ªçº¿ç¨‹å®‰å…¨ä½¿ç”¨
for (int i = 0; i < 4; ++i) {
    handles[i % handles.size()].spawn(producer(handles[i % handles.size()], queue, i+1, 5));
}
handles[0].spawn(consumer(handles[0], queue, 1, 20));
```

---

## ğŸ“Š æ€§èƒ½å¯¹æ¯”

| åœºæ™¯ | coroutine (æ”¹è¿›å) | async |
|------|-----------------|-------|
| å•çº¿ç¨‹åç¨‹ (1P1C) | ğŸŸ¢ æœ€å¿« | ğŸŸ¢ å¿« |
| å•çº¿ç¨‹åç¨‹ (NP1C) | ğŸŸ¢ å¿« | ğŸŸ¢ å¿« |
| å•çº¿ç¨‹åç¨‹ (NPMC) | ğŸŸ¢ å¿« | ğŸŸ¢ å¿« |
| **å¤šçº¿ç¨‹ (NP1C)** | âŒ å´©æºƒ | ğŸŸ¢ å¿« |
| **å¤šçº¿ç¨‹ (NPMC)** | âŒ å´©æºƒ | ğŸŸ¢ å¿« |

---

## ğŸ‰ æ€»ç»“

### å·²å®Œæˆ

1. âœ… æ·±å…¥åˆ†æä¸¤ä¸ª AsyncQueue å®ç°çš„ä¼˜ç¼ºç‚¹
2. âœ… æ”¹è¿› coroutine ç‰ˆæœ¬æ”¯æŒå¤šæ¶ˆè´¹è€…
3. âœ… æ˜ç¡®æŒ‡å‡ºå¤šçº¿ç¨‹å®‰å…¨æ€§çš„é™åˆ¶
4. âœ… åˆ›å»ºå…¨é¢çš„å•çº¿ç¨‹å’Œå¤šçº¿ç¨‹æµ‹è¯•å¥—ä»¶
5. âœ… å®ç°æ•°æ®å®Œæ•´æ€§éªŒè¯æœºåˆ¶
6. âœ… ç¼–è¯‘æµ‹è¯•é€šè¿‡ âœ…
7. âœ… ç”Ÿæˆè¯¦ç»†çš„åˆ†ææŠ¥å‘Šå’Œæœ€ä½³å®è·µæŒ‡å—

### æ ¸å¿ƒå»ºè®®

- ğŸ† **å¤šçº¿ç¨‹åº”ç”¨**ï¼šä½¿ç”¨ `async/AsyncQueue.h`ï¼ˆå”¯ä¸€å®‰å…¨é€‰æ‹©ï¼‰
- âœ… **å•çº¿ç¨‹åº”ç”¨**ï¼šå¯ä½¿ç”¨æ”¹è¿›çš„ `coroutine/AsyncQueue.hpp`
- âš ï¸ **å¼€å‘æ—¶**ï¼šå§‹ç»ˆä¼˜å…ˆè€ƒè™‘å¤šçº¿ç¨‹å®‰å…¨ç‰ˆæœ¬ï¼Œé™¤éæœ‰æ˜ç¡®çš„å•çº¿ç¨‹é™åˆ¶

---

## ğŸš€ ä¸‹ä¸€æ­¥

ç°åœ¨å¯ä»¥ï¼š
1. è¿è¡Œæµ‹è¯•éªŒè¯åŠŸèƒ½ï¼š`./build/test/test_async_queue`
2. åœ¨æ–°é¡¹ç›®ä¸­é‡‡ç”¨æ¨èçš„ async ç‰ˆæœ¬
3. å¦‚æœæœ‰æ€§èƒ½è¦æ±‚ï¼Œå¯åœ¨ç¡®è®¤å•çº¿ç¨‹åœºæ™¯åä½¿ç”¨æ”¹è¿›ç‰ˆæœ¬
4. å‚è€ƒè¯¦ç»†æŠ¥å‘Š `ASYNCQUEUE_COMPARISON_REPORT.md` äº†è§£æ›´å¤šæŠ€æœ¯ç»†èŠ‚
